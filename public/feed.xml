<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[leejihyeon.dev]]></title>
        <description><![CDATA[프론트엔드 개발자 블로그, leejihyeon.dev]]></description>
        <link>https://leejihyeon.dev</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Mon, 28 Jul 2025 08:08:20 GMT</lastBuildDate>
        <atom:link href="https://leejihyeon.dev/feed.xml" rel="self" type="application/rss+xml"/>
        <language><![CDATA[ko]]></language>
        <item>
            <title><![CDATA[서버부터 시작해서 프론트까지 블로그 제작기 (백엔드편)]]></title>
            <description><![CDATA[
  

# 백엔드편을 시작하며,
  

지난 글에서 '왜 이렇게 사용했지?' 라는 의문에서 시작해서, 내가 블로그를 만들때는 이렇게 만들어봐야겠다 라는 얘기를 
이번에는 **왜 Next.js의 백엔드 기능 대신 Spring Boot를 선택했는지**, 그리고 **어떤식으로 백엔드 구조를 설계했는지**에 대해 조금 더 자세히 풀어보려 합니다.

  

---

  

## 1. 왜 Next.js 대신 Spring Boot를 선택했을까?

  
Next.js는 프론트 프레임워크지만 백엔드 기능도 함께 제공됩니다. 저는 정적 콘텐츠 중심과 블로그라는 주제에 맞게 SEO의 최적화를 위해서 Next.js를 사용했습니다. 하지만 왜 Next.js에서 제공하는 백엔드 기능을 사용하지 않고 Spring Boot를 사용했을까? 항상 실행되는 내 PC 위 &apos;독립적인 서버&apos;를 만들어보고 싶었거든요.
Next.js의 API Routes는 프론트에서 필요한 데이터를 빠르게 가져오는 데는 정말 좋은데,
어디까지나 보조적인 느낌이 강해서 서버 자체를 운영하는 느낌은 아닌지라..
하지만 Spring은 Nginx 같은 리버스 프록시와 연결하면
**서버가 항상 켜져 있고**, **외부 요청을 계속해서 처리하는 구조**로 동작해서 
딱 제가 만들고 싶던 그런 형태의 백엔드였습니다.

---

  

### ✅ 역할 분리가 쉬운 구조

**Next.js의 백엔드 기능은 빠른 개발, 프론트와 백엔드의 통합, 직관적인 파일 기반 구조**  등으로 많은 개발자들에게 각광받고 있습니다.  
특히 소규모 프로젝트나 MVP를 구현할 때 유용합니다.

그러나 기능이 많아질수록  **비즈니스 로직과 프레젠테이션 레이어가 섞이기 쉬워지고**,  
그 결과 **코드의 관심사 분리(Separation of Concerns)**가 어려워져 유지보수가 점점 복잡해질 수 있다는 점.

그래서 필자는 이번 프로젝트에서는 이러한 문제를 사전에 방지하기 위해, 백엔드를 Spring으로 선택하였고, **전통적인 3계층 아키텍처(3-Tier Architecture)**  구조로 설계하였다.

-----------
| 계층         | 역할 설명 |
|--------------|-----------|
| **Controller** | 클라이언트(프론트엔드)로부터 들어오는 HTTP 요청을 수신하고, 해당 요청을 적절한 서비스 로직으로 전달한다. 요청에 대한 응답을 생성해 다시 클라이언트에 반환하는 역할을 한다. |
| **Service**    | 비즈니스 요구사항에 따른 핵심 로직을 처리하는 계층이다. 컨트롤러로부터 전달받은 데이터를 가공하거나, 여러 저장소를 조합해 로직을 수행하며, 트랜잭션 처리 등 중요한 업무 규칙을 책임진다. |
| **Repository** | 실제 데이터베이스와 연결되어 데이터를 조회하거나 저장하는 역할을 한다. 일반적으로 ORM(JPA, MyBatis 등)을 활용해 DB와의 직접적인 통신을 캡슐화하며, Service 계층에 필요한 데이터를 제공한다. |


계층을 명확히 나누면서 각 역할이 잘 분리되었고,  
기능이 확장되더라도 코드 수정이나 테스트가 훨씬 수월해졌다.  
실제로 기능이 복잡해질수록 이러한 구조의 장점이 더욱 분명하게 나타났다.

---

  


### ✅ 성능과 안정성

Java 기반이라 그런지 멀티스레드 환경에서도 안정적이고,  
부하가 걸려도 성능이 잘 유지되더라구요.  
사용자가 많아지거나 기능이 복잡해져도 비교적 든든한 느낌이었어요.

실제로 `k6`로 간단한 부하 테스트를 진행해봤습니다.  
200명의 가상 사용자가 1분간 동시에 요청을 보내도록 설정했는데요, 결과는 다음과 같았습니다.

```
checks_total.......................: 12000 196.809982/s  
checks_succeeded...................: 100.00% 12000 out of 12000  
checks_failed......................: 0.00% 0 out of 12000

✓ status is 200

http_req_duration..................: avg=13.04ms min=690µs med=4.77ms max=203.1ms p(90)=26.45ms p(95)=39.9ms  
http_req_failed....................: 0.00% 0 out of 12000  
http_reqs..........................: 12000 196.809982/s
```

서버 응답은 전부 성공했고, 평균 응답 속도도 13ms로 꽤 안정적이었어요.  
200명의 사용자가 동시에 접속했음에도 버벅임 없이 잘 작동해서, 개인 서버지만 생각보다 꽤 견고하다는 걸 확인할 수 있었습니다.


---
  

### ✅ 실무에서도 자주 쓰임

  

사실 이건 현실적인 이유기도 해요.
국내에서 Spring Boot는 워낙 많이 쓰이다 보니까,
이걸 이해하고 써보는 경험이 커리어에도 분명 도움이 될 거라 생각했습니다.

  

---

  

## 2. 3-Tier Architecture 설계

  

이번 백엔드는 전통적인 **3계층 아키텍처 (3-Tier Architecture)** 구조로 개발을 진행했습니다.


| 구분 | 3-Tier Architecture | Monolithic Architecture | MicroService Architecture |
| :--- | :--- | :--- | :--- |
| **구조** | 역할(표현, 비즈니스, 데이터)에 따라 3개의 논리적 계층으로 분리 | 모든 기능이 하나의 거대한 프로젝트 안에 결합됨 | 기능별로 잘게 쪼개진 독립적인 서비스들의 집합 |
| **장점** | 역할 분리로 코드 이해와 유지보수가 쉬움. 안정성과 체계성 확보. | 개발 초기 속도가 매우 빠르고, 배포가 단순함. | 기능별 확장성이 매우 뛰어남. 일부 서비스 장애가 전체에 영향을 주지 않음. |
| **단점** | 단순한 기능에는 과도한 설계일 수 있음. 프로젝트가 매우 커지면 계층 내부가 복잡해짐. | 프로젝트가 커질수록 코드가 얽혀 수정이 어렵고(스파게티 코드), 작은 수정에도 전체를 재배포해야 함. | 설계 및 관리가 매우 복잡함. 서비스 간 통신으로 인한 성능 문제 발생 가능. |
| **적합한 프로젝트** | **대부분의 웹 애플리케이션.** 개인 블로그부터 중소규모 서비스까지. | 아주 작은 토이 프로젝트나 프로토타입. | 넷플릭스, 아마존 같은 대규모 서비스. |

-  **Controller**: 외부에서 요청을 받고

-  **Service**: 로직을 처리하고

-  **Repository**: DB와 직접 연결되는 부분


```mermaid
graph TD
    subgraph "사용자 환경 (Client)"
        A[사용자 Browser]
    end

    subgraph "프론트엔드 (Vercel)"
        B[leejihyeon.dev(Next.js App)]
    end

    subgraph "백엔드 (개인 서버 - Mac)"
        D[Nginx<br>(HTTPS, Reverse Proxy)]
        E[Spring Boot(API Server, Port 8088)]
        F[PostgreSQL(Database)]
        G[AWS S3(Image Storage)]
    end

    C[인터넷]

    A -- "1. 페이지 요청" --> B
    B -- "2. API 요청<br>(api.leejihyeon.dev)" --> C
    C -- "3. HTTPS 요청 (Port 443)" --> D
    D -- "4. HTTP 요청 전달<br>(localhost:8088)" --> E
    E -- "5. 데이터 CRUD" --> F
    E -- "6. 이미지 업로드/조회" --> G

    G -- "응답" --> E
    F -- "응답" --> E
    E -- "응답" --> D
    D -- "응답" --> C
    C -- "응답" --> B
    B -- "응답 (UI 렌더링)" --> A
```

사용자는 제 블로그에 접속을 하고, 프론트단이 UI를 사용자에게 전송,
그리고 제 백엔드 API 엔드포인트에 요청을 보냅니다. 후에 포트포워딩된 포트주소로 요청이 도착하면 
Nginx는 HTTPS 요청을 받은 뒤에 내부의 Spring boot 서버로 전달하는 리벅스 프록시 역할을 하게됩니다.
그리고 Spring Boot 서버는 요청을 받아서 제 DB에서 글을 조회하거나 관리자 인증을 받은 권한으로 새로운 글을 저장하는 등  실제 비지니스 로직을 처리, 그리고 이미지는 S3를 연동을 해가지고 AWS S3와 통신을 하여 미디어 파일을 저장, 그 URL 을 받아옵니다. 그리고 모든 처리가 끝나게 되면 데이터는 다시 역순으로 Nginx -> 프론트엔드로 전달이 되고
사용자에게 전달이 되는 로직입니다.

  


  

### 게시글 조회 흐름, 예시

```java

// MemoController.java
@GetMapping("/api/memos/{id}")
	public MemoResponseDto  getMemo(@PathVariable  Long id) {
	return memoService.getMemo(id);
}

  

// MemoService.java
@Transactional(readOnly = true)
	public  MemoResponseDto getMemo(Long id) {
	Memo memo = findMemo(id);
	return new MemoResponseDto(memo);
}

  

// MemoRepository.java

public interface MemoRepository extends JpaRepository<Memo, Long> {}

```

### 🏛️ 폴더 구조는 이렇습니다

```
.  
├── config  
│   ├── AwsS3Config.java  
│   └── SecurityConfig.java  
├── controller  
│   ├── CategoryController.java  
│   ├── ImageUploadController.java  
│   ├── MemoController.java  
│   └── UserController.java  
├── domain  
│   ├── Category.java  
│   ├── Image.java  
│   ├── Memo.java  
│   ├── Timestamped.java  
│   └── User.java  
├── dto  
│   ├── CategoryResponseDto.java  
│   ├── MemoRequestDto.java  
│   ├── MemoResponseDto.java  
│   ├── MemoSitemapDto.java  
│   └── UserRequestDto.java  
├── jwt  
│   ├── JwtAuthorizationFilter.java  
│   └── JwtUtil.java  
├── repository  
│   ├── CategoryRepository.java  
│   ├── ImageRepository.java  
│   ├── MemoRepository.java  
│   └── UserRepository.java  
├── security  
│   ├── UserDetailsImpl.java  
│   └── UserDetailsServiceImpl.java  
├── service  
│   ├── CategoryService.java  
│   ├── MemoService.java  
│   ├── S3Uploader.java  
│   └── UserService.java  
└── DemoApplication.java
  ```

---

  
## 3. 인증 방식

어떤 **사전 과제** 에서 인증 로직을 구현하다가 JWT를 브라우저에 저장하는 걸 보고,  
'어..? 이렇게 저장하면 보안에 괜찮은 건가?'라는 생각이 들었어요.

그 의문이 꽤 오래 머릿속에 남았고, 결국 제가 직접 **JWT를 쿠키에 저장해서 보안에 안전한 백엔드를 만들어봐야겠다**는 계기가 되었습니다. Spring을 공부하며 REST API를 만드는 것도 그리고 지금 이 블로그에 포스팅하는 것도 그 사전과제 덕분이네요.

---

### localStorage는 왜 보안에 불안할까?

> 자바스크립트로 쉽게 접근 가능하고 악성 스크립트(XSS)가 들어오면 토큰이 고스란히 노출될 수 있어요.

그래서 선택한 방법이 ...

---

### ✅ HttpOnly 쿠키

토큰을 클라이언트가 직접 다루지 않게 하고, 쿠키로 관리하는 방식이에요.

- **HttpOnly**: JS에서 접근 불가 → XSS에 강함  
- **Secure**: HTTPS 환경에서만 쿠키 전송됨  
- **SameSite=None**: 프론트와 백엔드 도메인이 달라도 문제 없이 전송 가능

---

### 🧾 예시 코드

```java
// JwtUtil.java
public ResponseCookie createCookie(String token) {
    return ResponseCookie.from("Authorization", token)
        .path("/")
        .httpOnly(true)
        .secure(true)
        .sameSite("None")
        .build();
}

// UserController.java
@PostMapping("/login")
public ResponseEntity<String> login(@RequestBody UserRequestDto requestDto) {
    String token = userService.login(requestDto);
    ResponseCookie cookie = jwtUtil.createCookie(token);

    return ResponseEntity.ok()
        .header(HttpHeaders.SET_COOKIE, cookie.toString())
        .body("로그인 성공");
}
```

## 4. 기능 하나하나도 고민하며 만들었어요

  

### ✅ 이미지 업로드는 AWS S3로

처음에는 A부터 Z까지 클라우드 사용은 최대한 지양해야겠다고 생각했었습니다.
하지만 이미지같은 미디어들은 서버에 직접 이미지를 저장하면 디스크 용량도 부담되고,
나중에 서버를 여러 대로 확장할 때도 매우 복잡해진다는 말에 고민끝에 클라우드를 사용하기로 했습니다.

그래서 AWS S3에 업로드하고, **이미지 URL만 DB에 저장**하는 방식으로 처리했어요.



```bash

POST  /api/upload/image

```

1.`ImageUploadController`
프론트엔드가 보낸 이미지 파일 요청은 가장 먼저 ImageUploadController의
@PostMapping("/api/upload/image") 메서드에 도착합니다. 컨트롤러는 요청에 담겨온 MultipartFile을 받고, 실제 업로드 처리를 위해서 S3Uploader에게 파일을 그대로 전달합니다.

```java
// controller/ImageUploadController.java

@RestController
@RequiredArgsConstructor
public class ImageUploadController {
    private final S3Uploader s3Uploader;

    @PostMapping("/api/upload/image")
    public ResponseEntity<String> uploadImage(@RequestParam("image") MultipartFile image) throws IOException {
        String imageUrl = s3Uploader.upload(image, "content-images");
        return ResponseEntity.ok(imageUrl);
    }
}
```

2.`S3Uploader`

```java
// service/S3Uploader.java

@Service
@RequiredArgsConstructor
public class S3Uploader {

    private final S3Client s3Client;

    @Value("${aws.s3.bucket-name}")
    private String bucketName;

    public String upload(MultipartFile file, String dirName) throws IOException {
        String randomFilename = dirName + "/" + UUID.randomUUID() + "_" + file.getOriginalFilename();

        PutObjectRequest putObjectRequest = PutObjectRequest.builder()
                .bucket(bucketName)
                .key(randomFilename)
                .contentType(file.getContentType())
                .build();

        s3Client.putObject(putObjectRequest, RequestBody.fromInputStream(file.getInputStream(), file.getSize()));

        return s3Client.utilities().getUrl(builder -> builder.bucket(bucketName).key(randomFilename)).toExternalForm();
    }
}
```

중복된 파일네임이 설정이 되면 안되니 UUID로 이미지별 고유의 id를 줍니다.  
그리고 업로드 요청 객체를 생성하고, S3에 파일 업로드 합니다. 그리고 업로드된 파일의 URL을 반환하여
마크다운에서 S3에서 저장된 이미지의 주소를 사용합니다.
그 다음으로는 Spring이 `S3Uploader`에 주입해 줄 `S3Client` 객체를 어떻게 만들지 정의하는 설정입니다.

3.`AwsS3Config`
```java
// config/AwsS3Config.java

@Configuration
public class AwsS3Config {

    @Value("${aws.accessKeyId}")
    private String accessKey;

    @Value("${aws.secretAccessKey}")
    private String secretKey;

    @Value("${aws.region}")
    private String region;

    @Bean
    public S3Client s3Client() {
        AwsBasicCredentials credentials = AwsBasicCredentials.create(accessKey, secretKey);
        return S3Client.builder()
                .region(Region.of(region))
                .credentialsProvider(StaticCredentialsProvider.create(credentials))
                .build();
    }
}
```

---

  

### ✅ 카테고리는 다대다 관계로

Tag로도 사용되는 카테고리는 하나에 국한되지 않고 여러개를 사용합니다.
설계할때 여러 블로그 플랫폼들을 참조하였는데 요즘은 하나의 카테고리 - 여러 게시물이 아닌 
태그와 같은 많은 카테고리를 사용하더라구요. 실제로 그게 더 이점이 많아보였구요.
그래서 저도 이런 하나의 카테고리에 국한되지 않은 태그와 카테고리의 개념을 합쳐서 설계를 하였습니다.

게시글 하나에 여러 카테고리를 달 수 있고,
하나의 카테고리에 여러 게시글이 들어갈 수도 있어요.

그래서 다대다 관계를 설정을 하였습니다.
  

```java

@ManyToMany(fetch = FetchType.LAZY)

@JoinTable(
name = "memo_category",
joinColumns = @JoinColumn(name = "memo_id"),
inverseJoinColumns = @JoinColumn(name = "category_id")
)

private Set<Category> categories = new HashSet<>();

```

  

사용자가 입력한 카테고리 이름을 기준으로,

**이미 있으면 재사용하고, 없으면 새로 만드는 방식**으로 처리했어요.

덕분에 사용자 입장에선 훨씬 편하게 카테고리를 관리할 수 있죠.

  

---

  

## 마무리

  

이번에는 Spring Boot를 선택하게 된 이유,
그리고 어떤 구조와 방식으로 백엔드를 구성했는지를 공유해봤습니다.
글이 너무 길어지는 것 같아서
포트포워딩이나 중복포트 이슈, NAT Loopback 이슈 등은 나중에 네트워크편으로 따로 써야겠네요.😅

생전 처음 만지는 Spring boot 프레임워크를 이용해서 
정통적인 서버 구조를 직접 설계하고 구축해보는 과정이 쉽진 않았지만,
정말 많은 걸 배우게 된 시간이었습니다.

  

---

  

## 다음 편은?

  

다음 글에서는 이 백엔드와 연결된 **Next.js 프론트엔드 구성**,
그리고 **TanStack Query, Zustand를 이용한 상태 관리** 이야기를 해보려 합니다.

천천히 포스팅을 이어나가겠습니다. 감사합니다.]]></description>
            <link>https://leejihyeon.dev/posts/3</link>
            <guid isPermaLink="false">https://leejihyeon.dev/posts/3</guid>
            <pubDate>Sat, 26 Jul 2025 03:41:46 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[서버부터 시작해서 프론트까지 블로그 제작기 (도입)]]></title>
            <description><![CDATA[
## 도입부.

원래 목표는 간단했어요.  
블로그를 설계부터 구현까지 다 내 손으로 해보는 것!

원래 사용했던 velog가 있었는데 손이 잘 안가더라구요.  

그래서 제가 직접 만들면 포스팅을 자주할거같다는 생각에 블로그를 만들 계획은 있었습니다.

근데 제 계획에 서버는 전혀 생각 안 했었죠.

> “그냥 원래 하던대로 클라우드써서 데이터베이스 연결해서 뿌려야겠다”

이게 얼마나 순진한(편리한) 생각이었는지...

모든 시작은 어느 회사의 사전 과제였어요.  
거기서 인증 토큰을 브라우저 로컬/세션스토리지에 저장하는 걸 보고, 문득 의문이 들었죠.

💭 **“이거 왜 이렇게 했지?”**

그 인증 관련 보안에 대한 작은 의문이 결국 저를 ‘서버’라는 거대한 산으로 끌고 갔답니다.



## 그래서 결심했습니다.

포스팅만 하는 간단한 블로그라도,  

**HttpOnly 쿠키를 써서 안전하게 인증하는 방법부터 직접 만들어보고 싶었어요.**  

거기에 한 발짝 더 나아가서, AWS나 Vercel 같은 편리한 클라우드 말고  

시즈모드 상태인 제 맥미니를 24시간 잠 안 자는 서버로 직접 돌려보기로 했죠.

근데 그땐 몰랐죠...  

기본 개념은 알고 있었지만, 직접 네트워크 설정부터 포트 포워딩, 방화벽 규칙까지  

내 손으로 하나하나 만지고 부딪히면서 배우게 될 줄은... 😅

##  현실은 상상 이상...😭

Spring? 학교에서 배운건 자바 언어, 소켓프로그래밍이지
Spring이라는 프레임워크를 만져본적도 없었고 그냥 

💭 **“백엔드 프레임워크구나.”** 정도의 개념?

정말 문외한이었습니다. 그래도 뭔가 하나에 꽂히면 끝을 봐야하는 성격이기에,,

그리고 학습커브가 예전에 비해 많이 낮아졌다고 생각했기에,
도전해보자는 생각이 들었습니다.

실제로 3계층 아키텍처를 직접 구현하는 건 또 다른 차원이었어요.

공인 IP, 사설 IP, 포트 포워딩, NAT 루프백, 방화벽 개념도 알고 있었지만,  
직접 라우터 설정하고 방화벽 룰을 적용하며 터지는 에러를 마주하니 그게 훨씬 복잡하더라고요.

매일매일 터미널에 `403 Forbidden`, `CORS Error`, `BUILD FAILED`가 뜨고,   몇 번이고 좌절하면서도 결국 하나씩 해결해 나갔답니다.

## 앞으로의 포스팅,

⏳ 남은 시간 동안,  
이 좌충우돌 개발기와 배포 기록을  
하나씩 블로그에 차근차근 풀어보려 해요.

> 시작은 미약했지만, 끝은 창대할 거라 믿어요! 💪  
> 다음 편에서는 Spring 아키텍처 선정부터 시작해서 여러 삽질 이야기를 진솔하게 풀어보고 싶어요!
]]></description>
            <link>https://leejihyeon.dev/posts/2</link>
            <guid isPermaLink="false">https://leejihyeon.dev/posts/2</guid>
            <pubDate>Wed, 23 Jul 2025 04:50:54 GMT</pubDate>
        </item>
    </channel>
</rss>